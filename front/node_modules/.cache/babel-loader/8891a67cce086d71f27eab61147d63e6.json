{"ast":null,"code":"import _classCallCheck from \"/mnt/d/20160745/github/gadgetProj/front/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/mnt/d/20160745/github/gadgetProj/front/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * Maintains the history of an object\n */\nvar History =\n/*#__PURE__*/\nfunction () {\n  function History() {\n    var undoLimit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    _classCallCheck(this, History);\n\n    this.undoLimit = undoLimit;\n    this.undoList = [];\n    this.redoList = [];\n    this.current = null;\n    this.debug = debug;\n  }\n  /**\n   * Get the limit of undo/redo actions\n   *\n   * @returns {number|*} the undo limit, as it is configured when constructing the history instance\n   */\n\n\n  _createClass(History, [{\n    key: \"getUndoLimit\",\n    value: function getUndoLimit() {\n      return this.undoLimit;\n    }\n    /**\n     * Get Current state\n     *\n     * @returns {null|*}\n     */\n\n  }, {\n    key: \"getCurrent\",\n    value: function getCurrent() {\n      return this.current;\n    }\n    /**\n     * Keep an object to history\n     *\n     * This method will set the object as current value and will push the previous \"current\" object to the undo history\n     *\n     * @param obj\n     */\n\n  }, {\n    key: \"keep\",\n    value: function keep(obj) {\n      try {\n        this.redoList = [];\n\n        if (this.current) {\n          this.undoList.push(this.current);\n        }\n\n        if (this.undoList.length > this.undoLimit) {\n          this.undoList.shift();\n        }\n\n        this.current = obj;\n      } finally {\n        this.print();\n      }\n    }\n    /**\n     * Undo the last object, this operation will set the current object to one step back in time\n     *\n     * @returns the new current value after the undo operation, else null if no undo operation was possible\n     */\n\n  }, {\n    key: \"undo\",\n    value: function undo() {\n      try {\n        if (this.current) {\n          this.redoList.push(this.current);\n\n          if (this.redoList.length > this.undoLimit) {\n            this.redoList.shift();\n          }\n\n          if (this.undoList.length === 0) this.current = null;\n        }\n\n        if (this.undoList.length > 0) {\n          this.current = this.undoList.pop();\n          return this.current;\n        }\n\n        return null;\n      } finally {\n        this.print();\n      }\n    }\n    /**\n     * Redo the last object, redo happens only if no keep operations have been performed\n     *\n     * @returns the new current value after the redo operation, or null if no redo operation was possible\n     */\n\n  }, {\n    key: \"redo\",\n    value: function redo() {\n      try {\n        if (this.redoList.length > 0) {\n          if (this.current) this.undoList.push(this.current);\n          this.current = this.redoList.pop();\n          return this.current;\n        }\n\n        return null;\n      } finally {\n        this.print();\n      }\n    }\n    /**\n     * Checks whether we can perform a redo operation\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"canRedo\",\n    value: function canRedo() {\n      return this.redoList.length > 0;\n    }\n    /**\n     * Checks whether we can perform an undo operation\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"canUndo\",\n    value: function canUndo() {\n      return this.undoList.length > 0 || this.current !== null;\n    }\n    /**\n     * Clears the history maintained, can be undone\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.undoList = [];\n      this.redoList = [];\n      this.current = null;\n      this.print();\n    }\n  }, {\n    key: \"print\",\n    value: function print() {\n      if (this.debug) {\n        /* eslint-disable no-console */\n        console.log(this.undoList, ' -> ' + this.current + ' <- ', this.redoList.slice(0).reverse());\n      }\n    }\n  }]);\n\n  return History;\n}();\n\nexport default History;","map":{"version":3,"sources":["/mnt/d/20160745/github/gadgetProj/front/src/components/react-sketch/history.js"],"names":["History","undoLimit","debug","undoList","redoList","current","obj","push","length","shift","print","pop","console","log","slice","reverse"],"mappings":";;;AAAA;;;IAGMA,O;;;AACJ,qBAA2C;AAAA,QAA/BC,SAA+B,uEAAnB,EAAmB;AAAA,QAAfC,KAAe,uEAAP,KAAO;;AAAA;;AACzC,SAAKD,SAAL,GAAiBA,SAAjB;AACA,SAAKE,QAAL,GAAgB,EAAhB;AACA,SAAKC,QAAL,GAAgB,EAAhB;AACA,SAAKC,OAAL,GAAe,IAAf;AACA,SAAKH,KAAL,GAAaA,KAAb;AACD;AAED;;;;;;;;;mCAKe;AACb,aAAO,KAAKD,SAAZ;AACD;AAED;;;;;;;;iCAKa;AACX,aAAO,KAAKI,OAAZ;AACD;AAED;;;;;;;;;;yBAOKC,G,EAAK;AACR,UAAI;AACF,aAAKF,QAAL,GAAgB,EAAhB;;AACA,YAAI,KAAKC,OAAT,EAAkB;AAChB,eAAKF,QAAL,CAAcI,IAAd,CAAmB,KAAKF,OAAxB;AACD;;AACD,YAAI,KAAKF,QAAL,CAAcK,MAAd,GAAuB,KAAKP,SAAhC,EAA2C;AACzC,eAAKE,QAAL,CAAcM,KAAd;AACD;;AACD,aAAKJ,OAAL,GAAeC,GAAf;AACD,OATD,SASU;AACR,aAAKI,KAAL;AACD;AACF;AAED;;;;;;;;2BAKO;AACL,UAAI;AACF,YAAI,KAAKL,OAAT,EAAkB;AAChB,eAAKD,QAAL,CAAcG,IAAd,CAAmB,KAAKF,OAAxB;;AACA,cAAI,KAAKD,QAAL,CAAcI,MAAd,GAAuB,KAAKP,SAAhC,EAA2C;AACzC,iBAAKG,QAAL,CAAcK,KAAd;AACD;;AACD,cAAI,KAAKN,QAAL,CAAcK,MAAd,KAAyB,CAA7B,EAAgC,KAAKH,OAAL,GAAe,IAAf;AACjC;;AACD,YAAI,KAAKF,QAAL,CAAcK,MAAd,GAAuB,CAA3B,EAA8B;AAC5B,eAAKH,OAAL,GAAe,KAAKF,QAAL,CAAcQ,GAAd,EAAf;AACA,iBAAO,KAAKN,OAAZ;AACD;;AACD,eAAO,IAAP;AACD,OAbD,SAaU;AACR,aAAKK,KAAL;AACD;AACF;AAED;;;;;;;;2BAKO;AACL,UAAI;AACF,YAAI,KAAKN,QAAL,CAAcI,MAAd,GAAuB,CAA3B,EAA8B;AAC5B,cAAI,KAAKH,OAAT,EAAkB,KAAKF,QAAL,CAAcI,IAAd,CAAmB,KAAKF,OAAxB;AAClB,eAAKA,OAAL,GAAe,KAAKD,QAAL,CAAcO,GAAd,EAAf;AACA,iBAAO,KAAKN,OAAZ;AACD;;AACD,eAAO,IAAP;AACD,OAPD,SAOU;AACR,aAAKK,KAAL;AACD;AACF;AAED;;;;;;;;8BAKU;AACR,aAAO,KAAKN,QAAL,CAAcI,MAAd,GAAuB,CAA9B;AACD;AAED;;;;;;;;8BAKU;AACR,aAAO,KAAKL,QAAL,CAAcK,MAAd,GAAuB,CAAvB,IAA4B,KAAKH,OAAL,KAAiB,IAApD;AACD;AAED;;;;;;4BAGQ;AACN,WAAKF,QAAL,GAAgB,EAAhB;AACA,WAAKC,QAAL,GAAgB,EAAhB;AACA,WAAKC,OAAL,GAAe,IAAf;AACA,WAAKK,KAAL;AACD;;;4BAEO;AACN,UAAI,KAAKR,KAAT,EAAgB;AACd;AACAU,QAAAA,OAAO,CAACC,GAAR,CACE,KAAKV,QADP,EAEE,SAAS,KAAKE,OAAd,GAAwB,MAF1B,EAGE,KAAKD,QAAL,CAAcU,KAAd,CAAoB,CAApB,EAAuBC,OAAvB,EAHF;AAKD;AACF;;;;;;AAGH,eAAef,OAAf","sourcesContent":["/**\n * Maintains the history of an object\n */\nclass History {\n  constructor(undoLimit = 10, debug = false) {\n    this.undoLimit = undoLimit;\n    this.undoList = [];\n    this.redoList = [];\n    this.current = null;\n    this.debug = debug;\n  }\n\n  /**\n   * Get the limit of undo/redo actions\n   *\n   * @returns {number|*} the undo limit, as it is configured when constructing the history instance\n   */\n  getUndoLimit() {\n    return this.undoLimit;\n  }\n\n  /**\n   * Get Current state\n   *\n   * @returns {null|*}\n   */\n  getCurrent() {\n    return this.current;\n  }\n\n  /**\n   * Keep an object to history\n   *\n   * This method will set the object as current value and will push the previous \"current\" object to the undo history\n   *\n   * @param obj\n   */\n  keep(obj) {\n    try {\n      this.redoList = [];\n      if (this.current) {\n        this.undoList.push(this.current);\n      }\n      if (this.undoList.length > this.undoLimit) {\n        this.undoList.shift();\n      }\n      this.current = obj;\n    } finally {\n      this.print();\n    }\n  }\n\n  /**\n   * Undo the last object, this operation will set the current object to one step back in time\n   *\n   * @returns the new current value after the undo operation, else null if no undo operation was possible\n   */\n  undo() {\n    try {\n      if (this.current) {\n        this.redoList.push(this.current);\n        if (this.redoList.length > this.undoLimit) {\n          this.redoList.shift();\n        }\n        if (this.undoList.length === 0) this.current = null;\n      }\n      if (this.undoList.length > 0) {\n        this.current = this.undoList.pop();\n        return this.current;\n      }\n      return null;\n    } finally {\n      this.print();\n    }\n  }\n\n  /**\n   * Redo the last object, redo happens only if no keep operations have been performed\n   *\n   * @returns the new current value after the redo operation, or null if no redo operation was possible\n   */\n  redo() {\n    try {\n      if (this.redoList.length > 0) {\n        if (this.current) this.undoList.push(this.current);\n        this.current = this.redoList.pop();\n        return this.current;\n      }\n      return null;\n    } finally {\n      this.print();\n    }\n  }\n\n  /**\n   * Checks whether we can perform a redo operation\n   *\n   * @returns {boolean}\n   */\n  canRedo() {\n    return this.redoList.length > 0;\n  }\n\n  /**\n   * Checks whether we can perform an undo operation\n   *\n   * @returns {boolean}\n   */\n  canUndo() {\n    return this.undoList.length > 0 || this.current !== null;\n  }\n\n  /**\n   * Clears the history maintained, can be undone\n   */\n  clear() {\n    this.undoList = [];\n    this.redoList = [];\n    this.current = null;\n    this.print();\n  }\n\n  print() {\n    if (this.debug) {\n      /* eslint-disable no-console */\n      console.log(\n        this.undoList,\n        ' -> ' + this.current + ' <- ',\n        this.redoList.slice(0).reverse(),\n      );\n    }\n  }\n}\n\nexport default History;\n"]},"metadata":{},"sourceType":"module"}